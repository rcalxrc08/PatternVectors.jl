<!doctype html>
<html lang="en">
<head>
  <!-- META -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="rcalxrc08">
  <title>PatternVectors.jl</title>

  <link rel="icon" type="image/png"  href="/PatternVectors.jl/assets/favicon.ico">

  <!-- CSS -->
  
   <link rel="stylesheet" href="/PatternVectors.jl/libs/highlight/styles/atom-one-dark.css">
   
  <link rel="stylesheet" href="/PatternVectors.jl/css/bootstrap.min.css">
  <style>.bg-primary {
  background-color: #3f6388 !important;
}

a {
  color: #2669DD;
}

a:hover {
  color: teal;
}

.section-bg-color {
  background-color: #f6f8fa;
}

footer a {
  color: cornflowerblue;
}


header {
  margin-top: 55px !important;
}



.jumbotron {
  background-image: url("assets/diagonal-lines.svg");
  background-repeat: repeat;
}


/* CODE ADJUSTMENTS */

pre code.hljs {
  border-radius: 10px;
}

pre code.hljs.plaintext {
  margin-left: 15px;
}
</style>
  <link rel="stylesheet" href="/PatternVectors.jl/css/custom.css">

  <script async defer src="https://buttons.github.io/buttons.js"></script>
</head>
<body id="page-top">
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top" id="mainNav">
  <div class="container">
    <span class="navbar-brand">
      
        <img src="/PatternVectors.jl/assets/logo.svg" class="img-fluid" style="height:         25px;
padding-right:  10px;
" alt="Logo"/>
      
      <a href="#page-top">PatternVectors.jl</a>
      
    </span>
    <input type="checkbox" id="navbar-toggler-cbox" class="d-none" />
    <label for="navbar-toggler-cbox" class="navbar-toggler" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </label>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          <a class="nav-link" href="#about">About</a>
        </li>
        
        <li class="nav-item">
          <a class="nav-link" href="#usage">Usage</a>
        </li>
        
        <li class="nav-item">
          <a class="nav-link" href="#performances">Performances</a>
        </li>
        
        <li class="nav-item">
          <a class="nav-link" href="#gpu">GPU</a>
        </li>
        
        <li class="nav-item">
          <a class="nav-link" href="#new_patterns">New Patterns</a>
        </li>
        
      </ul>
    </div>
  </div>
</nav>

  <header class="text-white text-center">
  
    <div class="jumbotron jumbotron-fluid container-fluid bg-primary">
  
    <h1>PatternVectors.jl</h1>
    <div class="lead">Peculiar Vector Patterns.
</div>
    
      <a class="github-button" href="https://github.com/rcalxrc08/PatternVectors.jl" data-size="large" aria-label="View PatternVectors.jl on GitHub">View on GitHub</a>
    
    
      <a class="github-button" href="https://github.com/rcalxrc08/PatternVectors.jl" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star PatternVectors.jl on GitHub">Star</a>
    
  </div>
</header>

  <!-- Content appended here -->
<div class="franklin-content"><section id="about" class="scrollspy">
  <div class="container">
    <div class="row">
      <div class="col-lg-10 mx-auto">
        <h2>About this Package</h2> <div class="lead">PatternVectors.jl is a Julia package containing some useful array representation for peculiar one dimensional arrays patterns.</div> It currently contains the following pattern types:</p>
<ul>
<li><p>ZeroPattern: convenient representation for vectors of the form:</p>
</li>
</ul>
<pre><code class="julia hljs">[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.</span>..]</code></pre>
<ul>
<li><p>FillPattern: convenient representation for vectors of the form:</p>
</li>
</ul>
<pre><code class="julia hljs">[a,a,a,a,a,a...]</code></pre>
<ul>
<li><p>InitialValuePattern: convenient representation for vectors of the form:</p>
</li>
</ul>
<pre><code class="julia hljs">[a,b,b,b,b,b...]</code></pre>
<ul>
<li><p>FinalValuePattern: convenient representation for vectors of the form:</p>
</li>
</ul>
<pre><code class="julia hljs">[a,a,a,a,a,a...,b]</code></pre>
<ul>
<li><p>PaddedFillPattern: convenient representation for vectors of the form:</p>
</li>
</ul>
<pre><code class="julia hljs">[x,a,a,a,a,a...,y]</code></pre>
<ul>
<li><p>EvenOddPattern: convenient representation for vectors of the form:</p>
</li>
</ul>
<pre><code class="julia hljs">[a,b,a,b,a,b...]</code></pre>
<ul>
<li><p>PaddedEvenOddPattern: convenient representation for vectors of the form:</p>
</li>
</ul>
<pre><code class="julia hljs">[x,a,b,a,b,a,b...,y]</code></pre>
<p>Defining a new pattern is easy and fully supported by the library. The module is standalone.       </div>
    </div>
  </div>
</section>
<section id="usage" class="scrollspy section-bg-color">
  <div class="container">
    <div class="row">
      <div class="col-lg-10 mx-auto">
        <h2>Getting Started</h2> <strong><em>EvenOddPattern</em></strong></p>
<p>To build a EvenOddPattern one needs to provide:</p>
<ul>
<li><p>the value for odd indices</p>
</li>
<li><p>the value for even indices</p>
</li>
</ul>
<p>The various values must be of the same type and the length must be greater than one. The way to build an PatternVector with such pattern is the following:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> PatternVectors
value_odd=<span class="hljs-number">0.2</span>
value_even=<span class="hljs-number">2.3</span>
pattern=EvenOddPattern(value_odd,value_even)
length_av=<span class="hljs-number">7</span>
x_av=PatternVector(length_av,pattern)</code></pre><pre><code class="plaintext hljs">7-element PatternVector{Float64, EvenOddPattern{Float64}}:
 0.2
 2.3
 0.2
 2.3
 0.2
 2.3
 0.2</code></pre>
<p><strong><em>PaddedEvenOddPattern</em></strong></p>
<p>To build a PaddedEvenOddPattern one needs to provide: </p>
<ul>
<li><p>the initial value</p>
</li>
<li><p>the value for even indices</p>
</li>
<li><p>the value for odd indices</p>
</li>
<li><p>the final value</p>
</li>
</ul>
<p>The various values must be of the same type and the length must be greater than three. The way to build an PatternVector with such pattern is the following:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> PatternVectors
initial_value=<span class="hljs-number">0.2</span>
value_odd=-<span class="hljs-number">0.2</span>
value_even=<span class="hljs-number">2.3</span>
final_value=<span class="hljs-number">1.3</span>
length_av=<span class="hljs-number">7</span>
x_av=PatternVector(length_av,PaddedEvenOddPattern(initial_value,value_even,value_odd,final_value))</code></pre><pre><code class="plaintext hljs">7-element PatternVector{Float64, PaddedEvenOddPattern{Float64}}:
  0.2
  2.3
 -0.2
  2.3
 -0.2
  2.3
  1.3</code></pre>
<p><strong><em>Operation on Pattern Vectors</em></strong></p>
<p>The following applies:</p>
<ul>
<li><p>PatternVector is closed under getindex for range of integers.</p>
</li>
</ul>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> PatternVectors
apv=PatternVector(<span class="hljs-number">70</span>,PaddedEvenOddPattern(<span class="hljs-number">0.2</span>,-<span class="hljs-number">2.0</span>,<span class="hljs-number">4.0</span>,<span class="hljs-number">2.3</span>))
z_small=apv[<span class="hljs-number">1</span>:<span class="hljs-number">7</span>:<span class="hljs-number">50</span>]
z_small</code></pre><pre><code class="plaintext hljs">8-element PatternVector{Float64, PaddedEvenOddPattern{Float64}}:
  0.2
 -2.0
  4.0
 -2.0
  4.0
 -2.0
  4.0
 -2.0</code></pre>
<ul>
<li><p>Any scalar unary function applied directly to PatternVectors will produce an array of the same type.</p>
</li>
</ul>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> PatternVectors
pattern=EvenOddPattern(<span class="hljs-number">0.2</span>,-<span class="hljs-number">2.0</span>)
av=PatternVector(<span class="hljs-number">10</span>,pattern)
z_sin=@. sin(av)
z_sin</code></pre><pre><code class="plaintext hljs">10-element PatternVector{Float64, EvenOddPattern{Float64}}:
  0.19866933079506122
 -0.9092974268256817
  0.19866933079506122
 -0.9092974268256817
  0.19866933079506122
 -0.9092974268256817
  0.19866933079506122
 -0.9092974268256817
  0.19866933079506122
 -0.9092974268256817</code></pre>
<p><strong><em>Operation between Pattern Vectors</em></strong></p>
<p>The following applies:</p>
<ul>
<li><p>Binary scalar functions between PatternVectors will produce a PatternVector.</p>
</li>
<li><p>Binary scalar functions between PatternVector and <strong>any</strong> other type deriving from AbstractArray will produce an array of the other type.</p>
</li>
</ul>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> PatternVectors
x=PatternVector(<span class="hljs-number">10</span>,EvenOddPattern(<span class="hljs-number">0.2</span>,<span class="hljs-number">2.3</span>))
y=randn(<span class="hljs-number">10</span>)
z=PatternVector(<span class="hljs-number">10</span>,PaddedEvenOddPattern(<span class="hljs-number">0.2</span>,-<span class="hljs-number">2.0</span>,<span class="hljs-number">4.0</span>,<span class="hljs-number">2.3</span>))
@. sin(x)*y+z</code></pre><pre><code class="plaintext hljs">10-element Vector{Float64}:
  0.03668749056275791
 -3.615949324552841
  3.9980942677280678
 -1.9348731950470313
  4.2217184419271785
 -3.4917685592379595
  4.06900385825562
 -1.618795705513882
  4.171661430112774
  3.2085627162837826</code></pre>
<p>      </div>
    </div>
  </div>
</section>
<section id="performances" class="scrollspy">
  <div class="container">
    <div class="row">
      <div class="col-lg-10 mx-auto">
        <h2>Performances Comparison</h2> Here the common usages of the package are tested.</p>
<p><strong><em>Simple multiplication</em></strong></p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> PatternVectors, BenchmarkTools
n=<span class="hljs-number">10_000</span>
x=PatternVector(n,EvenOddPattern(<span class="hljs-number">0.2</span>,<span class="hljs-number">2.3</span>))
y=randn(n)
x_c=collect(x)
<span class="hljs-meta">@btime</span> @. $x*$y;
<span class="hljs-meta">@btime</span> @. $x_c*$y;</code></pre><pre><code class="plaintext hljs">  3.108 μs (3 allocations: 78.20 KiB)
  3.316 μs (3 allocations: 78.20 KiB)
</code></pre>
<p><strong><em>Flipping sign based on index and sum</em></strong></p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> PatternVectors, BenchmarkTools, LinearAlgebra
n=<span class="hljs-number">10_000</span>
<span class="hljs-keyword">function</span> f_std_scalar(f_x)
	N=length(f_x)
	sum_z=zero(eltype(f_x))
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:N
		w=ifelse(isodd(i),<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>)
		sum_z+=<span class="hljs-meta">@views</span> <span class="hljs-meta">@inbounds</span> w*f_x[i]
	<span class="hljs-keyword">end</span>
	<span class="hljs-keyword">return</span> sum_z
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> f_std_scalar_2(f_x)
	N=length(f_x)
	sum_z=zero(eltype(f_x))
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:N
		<span class="hljs-keyword">if</span>(isodd(i))
			sum_z+=<span class="hljs-meta">@views</span> <span class="hljs-meta">@inbounds</span> f_x[i]
		<span class="hljs-keyword">else</span>
			sum_z-=<span class="hljs-meta">@views</span> <span class="hljs-meta">@inbounds</span> f_x[i]
		<span class="hljs-keyword">end</span>
	<span class="hljs-keyword">end</span>
	<span class="hljs-keyword">return</span> sum_z
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> f_std_vec(f_x)
	N=length(f_x)
	idx=<span class="hljs-number">1</span>:N
	W=@. ifelse(isodd(idx),<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>)
	<span class="hljs-keyword">return</span> sum(W.*f_x)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> f_std_vec_linear_algebra(f_x)
	N=length(f_x)
	idx=<span class="hljs-number">1</span>:N
	W=@. ifelse(isodd(idx),<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>)
	<span class="hljs-keyword">return</span> dot(W,f_x)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> f_apv(f_x)
	N=length(f_x)
	W=PatternVector(n,EvenOddPattern(<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>))
	<span class="hljs-keyword">return</span> sum(W.*f_x)
<span class="hljs-keyword">end</span>
x=randn(n)
f_x=@. sin(x)+x*cos(x)
<span class="hljs-meta">@btime</span> f_std_scalar($f_x);
<span class="hljs-meta">@btime</span> f_std_scalar_2($f_x);
<span class="hljs-meta">@btime</span> f_std_vec($f_x);
<span class="hljs-meta">@btime</span> f_std_vec_linear_algebra($f_x);
<span class="hljs-meta">@btime</span> f_apv($f_x);</code></pre><pre><code class="plaintext hljs">  9.267 μs (0 allocations: 0 bytes)
  9.267 μs (0 allocations: 0 bytes)
  6.349 μs (6 allocations: 156.39 KiB)
  12.824 μs (2 allocations: 78.16 KiB)
  3.599 μs (3 allocations: 78.20 KiB)
</code></pre>
<p><strong><em>Simpson Integration</em></strong></p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> PatternVectors, BenchmarkTools,LinearAlgebra
n2=<span class="hljs-number">10_000</span>
<span class="hljs-keyword">function</span> f_simpson_std_scalar(f_x)
	N=length(f_x)
	sum_z=zero(eltype(f_x))
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:N
		w=ifelse(i==<span class="hljs-number">1</span>,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,ifelse(i==N,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,<span class="hljs-number">4</span>/<span class="hljs-number">3</span>))
		sum_z+=<span class="hljs-meta">@views</span> <span class="hljs-meta">@inbounds</span> w*f_x[i]
	<span class="hljs-keyword">end</span>
	<span class="hljs-keyword">return</span> sum_z
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> f_simpson_std_vec(f_x)
	N=length(f_x)
	idx=<span class="hljs-number">1</span>:N
	W=@. ifelse(idx==<span class="hljs-number">1</span>,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,ifelse(idx==N,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,<span class="hljs-number">4</span>/<span class="hljs-number">3</span>))
	<span class="hljs-keyword">return</span> sum(W.*f_x)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> f_simpson_std_vec_linear_algebra(f_x)
	N=length(f_x)
	idx=<span class="hljs-number">1</span>:N
	W=@. ifelse(idx==<span class="hljs-number">1</span>,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,ifelse(idx==N,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,<span class="hljs-number">4</span>/<span class="hljs-number">3</span>))
	<span class="hljs-keyword">return</span> dot(W,f_x)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> f_simpson_apv(f_x)
	N=length(f_x)
	W=PatternVector(N,PaddedEvenOddPattern(<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,<span class="hljs-number">4</span>/<span class="hljs-number">3</span>,<span class="hljs-number">4</span>/<span class="hljs-number">3</span>,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>))
	<span class="hljs-keyword">return</span> sum(W.*f_x)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> f_simpson_apv_linear_algebra(f_x)
	N=length(f_x)
	W=PatternVector(N,PaddedEvenOddPattern(<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,<span class="hljs-number">4</span>/<span class="hljs-number">3</span>,<span class="hljs-number">4</span>/<span class="hljs-number">3</span>,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>))
	<span class="hljs-keyword">return</span> dot(W,f_x)
<span class="hljs-keyword">end</span>

x2=randn(n2)
f_x2=@. sin(x2)+x2*cos(x2)
<span class="hljs-meta">@btime</span> f_simpson_std_scalar($f_x2);
<span class="hljs-meta">@btime</span> f_simpson_std_vec($f_x2);
<span class="hljs-meta">@btime</span> f_simpson_std_vec_linear_algebra($f_x2);
<span class="hljs-meta">@btime</span> f_simpson_apv($f_x2);
<span class="hljs-meta">@btime</span> f_simpson_apv_linear_algebra($f_x2);</code></pre><pre><code class="plaintext hljs">  9.267 μs (0 allocations: 0 bytes)
  6.773 μs (6 allocations: 156.39 KiB)
  4.082 μs (3 allocations: 78.20 KiB)
  3.992 μs (3 allocations: 78.20 KiB)
  9.277 μs (0 allocations: 0 bytes)
</code></pre>
<p>To be noticed the performance improvements thanks to the usage of PatternVector, and to be noticed that the first function proposed is not compatible with the CUDA.jl stack.</p>
<p>      </div>
    </div>
  </div>
</section>
<section id="gpu" class="scrollspy section-bg-color">
  <div class="container">
    <div class="row">
      <div class="col-lg-10 mx-auto">
        <h2>GPU Support</h2> The main objective of this library is to write code without iterating on indices for both cpu and gpu support. The main class is PatternVector which, unlike the standard arrays in julia, it is an immutable object, hence we can send it to gpu without issues, and being in most of the cases &#40;up to the client&#41; a lightweight object, this sending operation is efficient.       </div>
    </div>
  </div>
</section>
<section id="new_patterns" class="scrollspy">
  <div class="container">
    <div class="row">
      <div class="col-lg-10 mx-auto">
        <h2>New Patterns Definition</h2> In most of the cases the provided patterns suffice the applications.  In case you need a new pattern, the following steps are needed:</p>
<ul>
<li><p>Define a container &#40;namely MyNewPattern&#123;T&#125;&#41; inheriting from AbstractPattern&#123;T&#125; where T is the data type you are going to store in the array.</p>
</li>
<li><p>Define a constructor for it.</p>
</li>
<li><p>Implement the interface:</p>
<ul>
<li><p>pattern&#95;minimum&#95;size: define the minimum size for your type</p>
</li>
<li><p>getindex&#95;pattern: define the logic to extract scalars</p>
</li>
<li><p>getindex&#95;pattern_range: define the logic to extract ranges</p>
</li>
<li><p>materialize&#95;pattern: define the way to compute broadcasted functions with the new pattern</p>
</li>
</ul>
</li>
</ul>
<p>In case you need to mix your pattern with other existing patterns, you will have to specify we is the more general pattern able to store both:</p>
<ul>
<li><p>determine&#95;mixed&#95;pattern&#40;::Type&#123;T&#125;, ::Type&#123;V&#125;&#41; where &#123;T &lt;: MyNewPattern&#123;M&#125;, V &lt;: MyOldPattern&#123;N}} where &#123;M, N&#125; &#61; MyWinningPattern&#123;promote_type&#40;M, N&#41;&#125;</p>
</li>
</ul>
<p>And you are ready to go&#33;</p>
<p>In case you want to use your new pattern in AD applications you will have to provide two additional implementations:</p>
<ul>
<li><p>ChainRulesCore.rrule&#40;::Type&#123;MyNewPattern&#125;, args...&#41;: the rrule for the constructor of your newly defined pattern.</p>
</li>
<li><p>pattern&#95;to&#95;vector&#95;pullback: the rrule to convert from pattern to array.</p>
</li>
</ul>
<p>For more details have a look at the already implemented types.</p>
<p>      </div>
    </div>
  </div>
</section>
<footer class="py-5 bg-dark">
  <div class="container">
    <p class="m-0 text-center text-white">&copy; rcalxrc08. Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>, <a href="https://github.com/tlienart/PkgPage.jl">PkgPage.jl</a> and the <a href="https://julialang.org">Julia</a> programming language.</p>
  </div>
</footer>
</div><!-- CONTENT ENDS HERE -->
  
  
      


  
  <script src="/PatternVectors.jl/libs/simple-scrollspy.min.js"></script>
  <script>
  window.onload = function () {
    scrollSpy('#navbarResponsive', {
      sectionClass: '.scrollspy',
      menuActiveTarget: '.nav-link',
      offset: 100
    })
  }
  </script>
  </body>
</html>
